// =============================================================================
// SCHOLARLY PLATFORM — Sprint 11: S11-008
// Content Bounty Automation
// =============================================================================
// The Content Bounty system is the matchmaker between what the library needs
// and what the community can create. It analyses library coverage, generates
// bounty specifications, evaluates submissions, and manages DAO treasury payouts.
// =============================================================================

import { Result, ServiceError } from '../shared/base';

// =============================================================================
// SECTION 1: GAP ANALYSIS
// =============================================================================

export interface LibraryGapAnalysis {
  analysisId: string;
  tenantId: string;
  analysedAt: Date;
  totalBooks: number;
  gaps: LibraryGap[];
  coverageMatrix: CoverageMatrix;
  recommendations: GapRecommendation[];
}

export interface LibraryGap {
  gapId: string;
  type: GapType;
  severity: 'critical' | 'high' | 'medium' | 'low';
  description: string;
  currentCount: number;
  targetCount: number;
  deficit: number;
  filters: GapFilter;
}

export type GapType =
  | 'phase_coverage' | 'theme_coverage' | 'age_coverage'
  | 'language_coverage' | 'gpc_coverage' | 'art_style_variety'
  | 'series_depth' | 'difficulty_spread' | 'cultural_diversity';

export interface GapFilter {
  phonicsPhase?: number;
  theme?: string;
  ageGroup?: string;
  language?: string;
  targetGpcs?: string[];
  artStyle?: string;
  seriesId?: string;
  culturalContext?: string;
}

export interface CoverageMatrix {
  /** Phase × Theme coverage: count of books at each intersection */
  phaseTheme: Record<number, Record<string, number>>;
  /** Phase × Age coverage */
  phaseAge: Record<number, Record<string, number>>;
  /** Phase × Language coverage */
  phaseLanguage: Record<number, Record<string, number>>;
  /** GPC practise frequency across library */
  gpcFrequency: Record<string, number>;
  /** Art style distribution */
  artStyleDistribution: Record<string, number>;
  /** Cultural representation counts */
  culturalRepresentation: Record<string, number>;
}

export interface GapRecommendation {
  gapId: string;
  priority: number;
  suggestedBountyCount: number;
  estimatedCost: number;
  rationale: string;
}

// =============================================================================
// SECTION 2: BOUNTY SPECIFICATION
// =============================================================================

export interface ContentBounty {
  bountyId: string;
  tenantId: string;
  status: BountyStatus;
  title: string;
  description: string;
  requirements: BountyRequirements;
  reward: BountyReward;
  deadline: Date;
  maxSubmissions: number;
  currentSubmissions: number;
  winnerSubmissionId: string | null;
  sourceGapId: string;
  autoGenerated: boolean;
  createdAt: Date;
  publishedAt: Date | null;
  closedAt: Date | null;
  tags: string[];
}

export type BountyStatus =
  | 'draft' | 'published' | 'accepting_submissions'
  | 'evaluating' | 'awarded' | 'expired' | 'cancelled';

export interface BountyRequirements {
  phonicsPhase: number;
  targetGpcs: string[];
  minimumDecodability: number;
  ageGroup: string;
  theme: string;
  language: string;
  minPages: number;
  maxPages: number;
  artStylePreference: string | null;
  culturalContext: string | null;
  narrativeType: string;
  seriesId: string | null;
  qualityMinimumScore: number;
  mustIncludeIllustrations: boolean;
  mustIncludeNarration: boolean;
}

export interface BountyReward {
  type: 'token' | 'credit' | 'revenue_share' | 'featured_placement';
  tokenAmount: number;
  creditAmount: number;
  revenueSharePercentage: number;
  featuredDuration: number;
  bonusForEarlySubmission: number;
  bonusForExceptionalQuality: number;
  daoTreasurySource: string;
}

// =============================================================================
// SECTION 3: SUBMISSION & EVALUATION
// =============================================================================

export interface BountySubmission {
  submissionId: string;
  bountyId: string;
  creatorId: string;
  creatorDisplayName: string;
  status: SubmissionStatus;
  storybookId: string;
  submittedAt: Date;
  evaluation: SubmissionEvaluation | null;
  reviewNotes: string[];
}

export type SubmissionStatus =
  | 'submitted' | 'auto_evaluating' | 'peer_review'
  | 'accepted' | 'rejected' | 'revision_requested' | 'awarded';

export interface SubmissionEvaluation {
  evaluationId: string;
  submissionId: string;
  evaluatedAt: Date;
  scores: EvaluationScores;
  overallScore: number;
  meetsRequirements: boolean;
  issues: EvaluationIssue[];
  recommendation: 'accept' | 'reject' | 'revise';
  autoEvaluated: boolean;
}

export interface EvaluationScores {
  decodability: number;
  gpcCoverage: number;
  narrativeQuality: number;
  illustrationQuality: number;
  ageAppropriateness: number;
  curriculumAlignment: number;
  engagement: number;
  safety: number;
}

export interface EvaluationIssue {
  type: 'decodability' | 'safety' | 'quality' | 'requirements' | 'copyright';
  severity: 'blocker' | 'major' | 'minor';
  description: string;
  suggestion: string;
}

// =============================================================================
// SECTION 4: BOUNTY AUTOMATION SERVICE
// =============================================================================

export class BountyAutomationService {
  private readonly THEMES = [
    'animals', 'adventure', 'space', 'underwater', 'dinosaurs', 'fairy_tales',
    'everyday_life', 'friendship', 'nature', 'sports', 'food', 'music',
    'transport', 'seasons', 'family', 'school', 'superheroes', 'robots',
  ];

  private readonly AGE_GROUPS = ['3-5', '5-7', '7-9'];
  private readonly PHASE_TARGETS: Record<number, number> = { 2: 30, 3: 40, 4: 35, 5: 25, 6: 20 };

  /**
   * Analyse the library and identify coverage gaps.
   */
  async analyseLibraryGaps(
    tenantId: string,
    libraryStats: CoverageMatrix,
    totalBooks: number,
  ): Promise<Result<LibraryGapAnalysis>> {
    const gaps: LibraryGap[] = [];
    let gapIndex = 0;

    // Phase coverage gaps
    for (const [phase, target] of Object.entries(this.PHASE_TARGETS)) {
      const phaseNum = parseInt(phase);
      const themeMap = libraryStats.phaseTheme[phaseNum] ?? {};
      const phaseTotal = Object.values(themeMap).reduce((s, c) => s + c, 0);

      if (phaseTotal < target) {
        gaps.push({
          gapId: `gap_${gapIndex++}`,
          type: 'phase_coverage',
          severity: phaseTotal < target * 0.3 ? 'critical' : phaseTotal < target * 0.6 ? 'high' : 'medium',
          description: `Phase ${phaseNum} has ${phaseTotal} books, target is ${target}`,
          currentCount: phaseTotal,
          targetCount: target,
          deficit: target - phaseTotal,
          filters: { phonicsPhase: phaseNum },
        });
      }

      // Theme coverage within each phase
      for (const theme of this.THEMES) {
        const count = themeMap[theme] ?? 0;
        const themeTarget = Math.ceil(target / this.THEMES.length * 2); // At least 2 per major theme
        if (count < themeTarget) {
          gaps.push({
            gapId: `gap_${gapIndex++}`,
            type: 'theme_coverage',
            severity: count === 0 ? 'high' : 'medium',
            description: `Phase ${phaseNum} "${theme}" has ${count} books, needs ${themeTarget}`,
            currentCount: count,
            targetCount: themeTarget,
            deficit: themeTarget - count,
            filters: { phonicsPhase: phaseNum, theme },
          });
        }
      }
    }

    // GPC coverage gaps
    for (const [gpc, frequency] of Object.entries(libraryStats.gpcFrequency)) {
      if (frequency < 5) {
        gaps.push({
          gapId: `gap_${gapIndex++}`,
          type: 'gpc_coverage',
          severity: frequency === 0 ? 'critical' : frequency < 3 ? 'high' : 'medium',
          description: `GPC "${gpc}" only appears as target in ${frequency} books`,
          currentCount: frequency,
          targetCount: 5,
          deficit: 5 - frequency,
          filters: { targetGpcs: [gpc] },
        });
      }
    }

    // Cultural diversity gaps
    const totalCultural = Object.values(libraryStats.culturalRepresentation).reduce((s, c) => s + c, 0);
    for (const [context, count] of Object.entries(libraryStats.culturalRepresentation)) {
      const proportion = totalCultural > 0 ? count / totalCultural : 0;
      if (proportion < 0.05) { // Less than 5% representation
        gaps.push({
          gapId: `gap_${gapIndex++}`,
          type: 'cultural_diversity',
          severity: 'medium',
          description: `"${context}" represents only ${(proportion * 100).toFixed(1)}% of library`,
          currentCount: count,
          targetCount: Math.ceil(totalCultural * 0.05),
          deficit: Math.ceil(totalCultural * 0.05) - count,
          filters: { culturalContext: context },
        });
      }
    }

    // Sort by severity
    const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    gaps.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

    // Generate recommendations
    const recommendations: GapRecommendation[] = gaps
      .filter(g => g.severity === 'critical' || g.severity === 'high')
      .slice(0, 10)
      .map((gap, i) => ({
        gapId: gap.gapId,
        priority: i + 1,
        suggestedBountyCount: Math.min(gap.deficit, 5),
        estimatedCost: gap.deficit * 50, // 50 tokens per book bounty
        rationale: `${gap.description}. Filling this gap improves library coverage for affected learners.`,
      }));

    return {
      success: true,
      data: {
        analysisId: `analysis_${Date.now()}`,
        tenantId,
        analysedAt: new Date(),
        totalBooks,
        gaps,
        coverageMatrix: libraryStats,
        recommendations,
      },
    };
  }

  /**
   * Auto-generate bounties from gap analysis results.
   */
  async generateBounties(
    analysis: LibraryGapAnalysis,
    maxBounties: number = 10,
  ): Promise<Result<ContentBounty[]>> {
    const bounties: ContentBounty[] = [];

    for (const rec of analysis.recommendations.slice(0, maxBounties)) {
      const gap = analysis.gaps.find(g => g.gapId === rec.gapId);
      if (!gap) continue;

      for (let i = 0; i < rec.suggestedBountyCount; i++) {
        const bounty: ContentBounty = {
          bountyId: `bounty_${Date.now()}_${bounties.length}`,
          tenantId: analysis.tenantId,
          status: 'draft',
          title: this.generateBountyTitle(gap),
          description: this.generateBountyDescription(gap),
          requirements: {
            phonicsPhase: gap.filters.phonicsPhase ?? 3,
            targetGpcs: gap.filters.targetGpcs ?? [],
            minimumDecodability: 0.85,
            ageGroup: gap.filters.ageGroup ?? '5-7',
            theme: gap.filters.theme ?? 'any',
            language: gap.filters.language ?? 'en',
            minPages: 8,
            maxPages: 16,
            artStylePreference: gap.filters.artStyle ?? null,
            culturalContext: gap.filters.culturalContext ?? null,
            narrativeType: 'fiction',
            seriesId: gap.filters.seriesId ?? null,
            qualityMinimumScore: 0.7,
            mustIncludeIllustrations: true,
            mustIncludeNarration: false,
          },
          reward: {
            type: 'token',
            tokenAmount: 50,
            creditAmount: 0,
            revenueSharePercentage: 5,
            featuredDuration: 0,
            bonusForEarlySubmission: 10,
            bonusForExceptionalQuality: 25,
            daoTreasurySource: 'content_bounty_pool',
          },
          deadline: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days
          maxSubmissions: 10,
          currentSubmissions: 0,
          winnerSubmissionId: null,
          sourceGapId: gap.gapId,
          autoGenerated: true,
          createdAt: new Date(),
          publishedAt: null,
          closedAt: null,
          tags: this.generateBountyTags(gap),
        };
        bounties.push(bounty);
      }
    }

    return { success: true, data: bounties };
  }

  /**
   * Auto-evaluate a bounty submission against requirements.
   */
  async evaluateSubmission(
    submission: BountySubmission,
    bounty: ContentBounty,
    storyMetadata: StoryMetadataForEvaluation,
  ): Promise<Result<SubmissionEvaluation>> {
    const issues: EvaluationIssue[] = [];

    // Decodability check
    const decodScore = storyMetadata.decodabilityScore;
    if (decodScore < bounty.requirements.minimumDecodability) {
      issues.push({
        type: 'decodability',
        severity: decodScore < 0.6 ? 'blocker' : 'major',
        description: `Decodability ${(decodScore * 100).toFixed(0)}% below minimum ${(bounty.requirements.minimumDecodability * 100).toFixed(0)}%`,
        suggestion: 'Replace non-decodable words with alternatives from the taught GPC set.',
      });
    }

    // GPC coverage check
    const requiredGpcs = new Set(bounty.requirements.targetGpcs);
    const coveredGpcs = new Set(storyMetadata.gpcsUsed);
    const missingGpcs = [...requiredGpcs].filter(g => !coveredGpcs.has(g));
    const gpcScore = requiredGpcs.size > 0
      ? (requiredGpcs.size - missingGpcs.length) / requiredGpcs.size
      : 1.0;
    if (missingGpcs.length > 0) {
      issues.push({
        type: 'requirements',
        severity: missingGpcs.length > requiredGpcs.size / 2 ? 'blocker' : 'major',
        description: `Missing target GPCs: ${missingGpcs.join(', ')}`,
        suggestion: 'Include words featuring these GPCs in the story.',
      });
    }

    // Safety check
    const safetyScore = storyMetadata.safetyPassed ? 1.0 : 0;
    if (!storyMetadata.safetyPassed) {
      issues.push({
        type: 'safety',
        severity: 'blocker',
        description: 'Content safety check failed.',
        suggestion: 'Review flagged content and revise.',
      });
    }

    // Page count check
    if (storyMetadata.pageCount < bounty.requirements.minPages || storyMetadata.pageCount > bounty.requirements.maxPages) {
      issues.push({
        type: 'requirements',
        severity: 'major',
        description: `Book has ${storyMetadata.pageCount} pages, requirement is ${bounty.requirements.minPages}-${bounty.requirements.maxPages}`,
        suggestion: `Adjust story length to ${bounty.requirements.minPages}-${bounty.requirements.maxPages} pages.`,
      });
    }

    const scores: EvaluationScores = {
      decodability: decodScore,
      gpcCoverage: gpcScore,
      narrativeQuality: storyMetadata.narrativeScore,
      illustrationQuality: storyMetadata.hasIllustrations ? storyMetadata.illustrationScore : 0,
      ageAppropriateness: storyMetadata.ageAppropriatenessScore,
      curriculumAlignment: gpcScore * 0.5 + decodScore * 0.5,
      engagement: storyMetadata.engagementScore,
      safety: safetyScore,
    };

    const weights = { decodability: 0.2, gpcCoverage: 0.15, narrativeQuality: 0.15, illustrationQuality: 0.1, ageAppropriateness: 0.1, curriculumAlignment: 0.15, engagement: 0.1, safety: 0.05 };
    const overallScore = Object.entries(scores).reduce((sum, [key, val]) => sum + val * (weights[key as keyof typeof weights] ?? 0.1), 0);

    const hasBlockers = issues.some(i => i.severity === 'blocker');
    const meetsRequirements = !hasBlockers && overallScore >= bounty.requirements.qualityMinimumScore;

    return {
      success: true,
      data: {
        evaluationId: `eval_${Date.now()}`,
        submissionId: submission.submissionId,
        evaluatedAt: new Date(),
        scores,
        overallScore,
        meetsRequirements,
        issues,
        recommendation: hasBlockers ? 'reject' : meetsRequirements ? 'accept' : 'revise',
        autoEvaluated: true,
      },
    };
  }

  /**
   * Select winner from evaluated submissions and distribute rewards.
   */
  async awardBounty(
    bounty: ContentBounty,
    evaluatedSubmissions: Array<{ submission: BountySubmission; evaluation: SubmissionEvaluation }>,
  ): Promise<Result<BountyAwardResult>> {
    const eligible = evaluatedSubmissions
      .filter(s => s.evaluation.meetsRequirements)
      .sort((a, b) => b.evaluation.overallScore - a.evaluation.overallScore);

    if (eligible.length === 0) {
      return { success: false, error: { code: 'NO_ELIGIBLE', message: 'No submissions meet requirements.' } };
    }

    const winner = eligible[0];
    const isExceptional = winner.evaluation.overallScore >= 0.9;
    const isEarly = winner.submission.submittedAt < new Date(bounty.deadline.getTime() - 7 * 24 * 60 * 60 * 1000);

    let totalReward = bounty.reward.tokenAmount;
    const bonuses: string[] = [];
    if (isEarly) { totalReward += bounty.reward.bonusForEarlySubmission; bonuses.push('Early submission bonus'); }
    if (isExceptional) { totalReward += bounty.reward.bonusForExceptionalQuality; bonuses.push('Exceptional quality bonus'); }

    return {
      success: true,
      data: {
        bountyId: bounty.bountyId,
        winnerSubmissionId: winner.submission.submissionId,
        winnerCreatorId: winner.submission.creatorId,
        winnerScore: winner.evaluation.overallScore,
        tokenReward: totalReward,
        bonusesApplied: bonuses,
        revenueShareEnabled: bounty.reward.revenueSharePercentage > 0,
        revenueSharePercentage: bounty.reward.revenueSharePercentage,
        runnersUp: eligible.slice(1, 4).map(s => ({
          submissionId: s.submission.submissionId,
          creatorId: s.submission.creatorId,
          score: s.evaluation.overallScore,
          consolationReward: Math.round(bounty.reward.tokenAmount * 0.1),
        })),
      },
    };
  }

  /**
   * Run the full automation pipeline: analyse → generate → publish bounties.
   */
  async runAutomationCycle(
    tenantId: string,
    libraryStats: CoverageMatrix,
    totalBooks: number,
  ): Promise<Result<AutomationCycleResult>> {
    const analysisResult = await this.analyseLibraryGaps(tenantId, libraryStats, totalBooks);
    if (!analysisResult.success) return { success: false, error: analysisResult.error };

    const bountiesResult = await this.generateBounties(analysisResult.data!);
    if (!bountiesResult.success) return { success: false, error: bountiesResult.error };

    return {
      success: true,
      data: {
        analysisId: analysisResult.data!.analysisId,
        gapsFound: analysisResult.data!.gaps.length,
        criticalGaps: analysisResult.data!.gaps.filter(g => g.severity === 'critical').length,
        bountiesGenerated: bountiesResult.data!.length,
        estimatedTotalCost: bountiesResult.data!.reduce((s, b) => s + b.reward.tokenAmount, 0),
        bounties: bountiesResult.data!,
      },
    };
  }

  private generateBountyTitle(gap: LibraryGap): string {
    const phase = gap.filters.phonicsPhase ? `Phase ${gap.filters.phonicsPhase}` : '';
    const theme = gap.filters.theme ?? '';
    const age = gap.filters.ageGroup ?? '';
    switch (gap.type) {
      case 'phase_coverage': return `Create ${phase} Storybooks`;
      case 'theme_coverage': return `${phase} "${theme}" Stories Needed`;
      case 'gpc_coverage': return `Stories Featuring ${gap.filters.targetGpcs?.join(', ')} GPCs`;
      case 'cultural_diversity': return `Culturally Diverse ${phase} Stories`;
      default: return `Content Needed: ${gap.description.slice(0, 50)}`;
    }
  }

  private generateBountyDescription(gap: LibraryGap): string {
    return `The Scholarly library needs more content to fill a gap: ${gap.description}. ` +
      `We currently have ${gap.currentCount} books but need at least ${gap.targetCount}. ` +
      `Help our learners by creating engaging, decodable storybooks that fill this gap!`;
  }

  private generateBountyTags(gap: LibraryGap): string[] {
    const tags: string[] = [gap.type];
    if (gap.filters.phonicsPhase) tags.push(`phase_${gap.filters.phonicsPhase}`);
    if (gap.filters.theme) tags.push(gap.filters.theme);
    if (gap.filters.ageGroup) tags.push(gap.filters.ageGroup);
    if (gap.filters.language) tags.push(gap.filters.language);
    return tags;
  }
}

export interface StoryMetadataForEvaluation {
  decodabilityScore: number;
  gpcsUsed: string[];
  pageCount: number;
  wordCount: number;
  safetyPassed: boolean;
  narrativeScore: number;
  illustrationScore: number;
  hasIllustrations: boolean;
  ageAppropriatenessScore: number;
  engagementScore: number;
}

export interface BountyAwardResult {
  bountyId: string;
  winnerSubmissionId: string;
  winnerCreatorId: string;
  winnerScore: number;
  tokenReward: number;
  bonusesApplied: string[];
  revenueShareEnabled: boolean;
  revenueSharePercentage: number;
  runnersUp: Array<{ submissionId: string; creatorId: string; score: number; consolationReward: number }>;
}

export interface AutomationCycleResult {
  analysisId: string;
  gapsFound: number;
  criticalGaps: number;
  bountiesGenerated: number;
  estimatedTotalCost: number;
  bounties: ContentBounty[];
}

// =============================================================================
// SECTION 5: NATS EVENTS
// =============================================================================

export const BOUNTY_EVENTS = {
  GAP_ANALYSIS_COMPLETED: 'scholarly.bounty.gap_analysis_completed',
  BOUNTY_GENERATED: 'scholarly.bounty.bounty_generated',
  BOUNTY_PUBLISHED: 'scholarly.bounty.bounty_published',
  SUBMISSION_RECEIVED: 'scholarly.bounty.submission_received',
  SUBMISSION_EVALUATED: 'scholarly.bounty.submission_evaluated',
  BOUNTY_AWARDED: 'scholarly.bounty.bounty_awarded',
  REWARD_DISTRIBUTED: 'scholarly.bounty.reward_distributed',
  AUTOMATION_CYCLE_COMPLETE: 'scholarly.bounty.automation_cycle_complete',
} as const;

// =============================================================================
// EXPORTS
// =============================================================================
export {
  BountyAutomationService,
  BOUNTY_EVENTS,
};
